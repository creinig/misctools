#!/usr/bin/env ruby

# TODO:
# - yardoc etc
# - tests

require "fileutils"

RUN_TS = Time.now

class Bt1Char
  STRUCTURE = {
    # attr, startidx, pack_pattern [, read_postprocessor]
    name: [0x00, "a16", lambda {|v| v.split("\x00")[0] }],
    st_cur: [0x17, "s<"],
    iq_cur: [0x19, "s<"],
    dx_cur: [0x1b, "s<"],
    cn_cur: [0x1d, "s<"],
    lk_cur: [0x1f, "s<"],
    st: [0x21, "s<"],
    iq: [0x23, "s<"],
    dx: [0x25, "s<"],
    cn: [0x27, "s<"],
    lk: [0x29, "s<"],
    hp: [0x2d, "s<"],
    hp_cur: [0x2f, "s<"],
    sp_cur: [0x31, "s<"],
    sp: [0x33, "s<"],
    exp: [0x45, "l<"],
    gold: [0x49, "l<"],
    con_lvl: [0x52, "C"],
    mag_lvl: [0x53, "C"],
    sor_lvl: [0x54, "C"]
  }

  def method_missing(name, *args)
    attr = name.to_s.delete_suffix("=").to_sym
    spec = STRUCTURE[attr]
    return super unless spec

    if name.end_with? "="
      binary = args.pack(spec[1])
      @data[spec[0], binary.size] = binary
    else
      val = @data[spec[0], 32].unpack1(spec[1])
      spec[2] ? spec[2].yield(val) : val
    end
  end

  attr_reader :filename

  def initialize(filename)
    @data = File.open(filename, "rb") { |f| f.read }
    raise "Not a character" unless is_char
    @filename = filename
  end

  # Display character summary
  def show
    puts "Name:  #{name}"
    puts "Attrs: ST #{st_cur}/#{st}, IQ #{iq_cur}/#{iq}, DX #{dx_cur}/#{dx}, CN #{cn_cur}/#{cn}, LK #{lk_cur}/#{lk}"
    puts "HP:    #{hp_cur}/#{hp}"
    puts "SP:    #{sp_cur}/#{sp}, Spell lvls (Con/Mag/Sor): #{con_lvl}/#{mag_lvl}/#{sor_lvl}"
    puts "Exp:   #{exp}"
    puts "Gold:  #{gold}"
  end

  # Heal character (fill HP and SP)
  def heal
    self.hp_cur = hp
    self.sp_cur = sp
    self.st_cur, self.dx_cur, self.iq_cur, self.cn_cur, self.lk_cur = st, dx, iq, cn, lk
  end

  # Write character back, storing a backup copy in ./backup
  def write
    bkp = backup
    File.open(@filename, "wb") { |f| f.write(@data) }
    puts "Written to #{@filename}, original kept as #{bkp}"
  end

  private

  def is_char
    @data[0x10].unpack1("c") == 0x01
  end

  def backup
    dest = "backup/#{Time.now.strftime('%FT%T%:z')}"
    target = "#{dest}/#{@filename}"
    FileUtils.mkdir_p(dest)
    FileUtils.cp(@filename, target)
    target
  end
end

class Operations
  def initialize(cmd_args)
    cmd_args = ["show"] if cmd_args.empty?

    @write_at_end = false
    @modifies = false

    @ops = cmd_args.map do |cmd|
      case cmd.split("=")
      in ["show"]
        lambda { |char| char.show }
      in ["heal"]
        @modifies = true
        lambda { |char| char.heal }
      in /^\w+$/ => property, /^\d+$/ => val
        @modifies = true
        raise "No property <#{property}>" unless Bt1Char::STRUCTURE.key? property.to_sym
        lambda { |char| char.send("#{property}=", val.to_i) }
      in /^\w+$/ => property, /^\w+$/ => val
        @modifies = true
        raise "No property <#{property}>" unless Bt1Char::STRUCTURE.key? property.to_sym
        lambda { |char| char.send("#{property}=", val.upcase) }
      in ["-w"]
        @write_at_end = true
        nil
      else
        raise "Unknown command <#{cmd}>"
      end
    end.compact
  end

  def run(char)
    @ops.each { |op| op.yield(char) }
    char.write if @modifies && @write_at_end
  end
end

def supported_file?(filename, expected_size)
  return false unless filename.downcase.end_with? ".tpw"
  stat = File.stat(filename)
  stat.file? && (stat.size == expected_size)
end

def char?(filename) = supported_file?(filename, 109)
def party?(filename) = supported_file?(filename, 113)

def load_chars(files)
  f_chars = files.select { |f| char?(f) }
  f_parties = files.select { |f| party?(f) }
  f_other = files - f_chars - f_parties

  unless f_other.empty?
    puts "Unsupported kind of file: #{f_other.join(", ")}"
    exit 1
  end

  chars = f_chars.map { |f| Bt1Char.new(f) }
  chars += f_parties.map { |f| resolve_party(f) }.flatten
  chars.uniq { |c| c.filename }
end

def resolve_party(filename)
  data = File.binread(filename)
  names = (0..6)
    .map { |i| 0x11 + (i * 0x10) }
    .map { |i| data[i, 16].unpack1("a16").split("\x00")[0] }
    .compact
  Dir.new(File.dirname(filename))
    .select { |e| char? e }
    .map { |f| Bt1Char.new(f) }
    .select { |c| names.include? c.name }
end

def usage
  puts <<USAGE
  Bard's Tale 1 (DOS) Character Editor

  Usage: bt1edit [options actions files]

  Example: bt1edit -w st=18 exp=4000 heal show *.tpw

  Options:
    -w       write modified character [false]

  Actions (executed in order, default "show"):
    show     print character summary
    heal     set current hp, sp and attrs to their "full" values
    prop=val set specific property to <val>

  Files:
    Any character or party files. Parties will be automatically
    resolved to their members.

  Supported properties:
    #{Bt1Char::STRUCTURE.keys.join(", ")}

USAGE
end

# Main ---------------------------

files = ARGV.select { |a| File.exist? a }
commands = ARGV - files
ops = begin
        Operations.new(commands)
      rescue RuntimeError => e
        puts e.message
        exit 1
      end

if files.empty?
  usage
  exit 0
end

load_chars(files).each do |char|
  puts ">> #{char.filename}"
  ops.run(char)
rescue RuntimeError => e
  puts e.message
end
